<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Atcoder.JOIOJI]]></title>
    <url>%2F2019%2F07%2F29%2FAtcoder.JOIOJI%2F</url>
    <content type="text"><![CDATA[题目描述 JOIOJI桑是JOI君的叔叔。“JOIOJI”这个名字是由“J、O、I”三个字母各两个构成的。 最近，JOIOJI桑有了一个孩子。JOIOJI桑想让自己孩子的名字和自己一样由“J、O、I”三个字母构成，并且想让“J、O、I”三个字母的出现次数恰好相同 。 JOIOJI桑家有一份祖传的卷轴，上面写着一首长诗，长度为N，由“J、O、I”三个字母组成。JOIOJIさん想用诗中最长的满足要求的连续子串作为孩子的名字。 现在JOIOJI桑将这首长诗交给了你，请你求出诗中最长的、包含同样数目的“J、O、I”三个字母的连续子串。 输入 第一行一个正整数N，代表这首长诗的长度 接下来一行一个长度为N的字符串S，表示这首长诗，保证每个字符都是“J、O、I”三个字母中的一个 N&lt;=200000 输出 输出一行一个正整数，代表最长的包含等数量“J、O、I”三个字母的最长连续子串的长度。如果不存在这样的子串，输出0 样例输入 10 JOIIJOJOOI 样例输出 6 同样，2*10^5数据范围 N * N肯定也不可行，考虑别的办法。 思路参考引自：https://fighting-naruto.blog.luogu.org/solution-at1224 如果用1，2，3分别代表 J,O,I ，用 si[j] 表示 前 j 个位置有多少个 i ，那么区间[i,j]满足条件有： s1[j] - s1[i-1] = s2[j] - s2[i-1] = s3[j] - s3[i-1] 移项化简 设s2[i] - s1[i] = x[i] , s3[i] - s1[i] = y[i]，则只要满足x[j]=x[i-1]并且y[j] = y[i-1]就说明区间[i,j]满足条件 最后只需要找x,y相同的最大的区间[i,j]即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int N = 200005;typedef long long ll;using namespace std;ll ans=0;struct node&#123; int x,y,id;&#125;a[N];char ch;bool cmp(node a,node b)&#123; return a.x&lt;b.x || (a.x==b.x&amp;&amp;a.y&lt;b.y)|| (a.x==b.x&amp;&amp;a.y==b.y&amp;&amp;a.id&lt;b.id);&#125;ll maxx(ll xx,ll yy)&#123; if(xx&gt;yy)&#123; return xx; &#125;return yy;&#125;int main()&#123; int n; cin&gt;&gt;n;//x[i]=s2[i]-s1[i] y[i]=s3[i]-s1[i] for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;ch; a[i].id=i; if(ch=='J')&#123; a[i].x=a[i-1].x-1; a[i].y=a[i-1].y-1; &#125;if(ch=='O')&#123; a[i].x=a[i-1].x+1; a[i].y=a[i-1].y; &#125;if(ch=='I')&#123; a[i].x=a[i-1].x; a[i].y=a[i-1].y+1; &#125; &#125; sort(a,a+n+1,cmp); int t=a[0].id; for(ll i=1;i&lt;=n;i++)&#123; if(a[i].x==a[i-1].x &amp;&amp; a[i].y==a[i-1].y) ans=maxx(ans,a[i].id-t); else t=a[i].id; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NowCoder Crazy Binary String]]></title>
    <url>%2F2019%2F07%2F29%2FNowCoder.CrazyBinaryString%2F</url>
    <content type="text"><![CDATA[题目描述 链接：https://ac.nowcoder.com/acm/contest/883/B ZYB loves binary strings (strings that only contains 0 and1’). And he loves equal binary strings more, where the number of 0and the number of 1 in the string are equal. ZYB wants to choose a substring from an original string T so that it is an equal binary stringwith the longest length possible. He also wants to choose a subsequence of T which meets the same requirements. A string v is a substring of a string w if v is empty, or there are two integers l and r (1≤l≤r≤∣w∣) such that v=wl*wl+1 ⋯wr A string v is a subsequence of a string w if it can be derived from w by deleting any number (including zero) of characters without changing the order of the remaining characters. For simplicity, you only need to output the maximum possible length. Note that the empty string is both a substring and a subsequence of any string. 输入描述 The first line of the input contains a single integer N (1≤N≤100000)，the length of the original string T. The second line contains a binary string with exactly N characters, the original string T 输出描述 Print two integers A and B, denoting the answer for substring and subsequence respectively. 示例输入 8 0100101001 示例输出 4 6 分析这道题目的时候，10^5用N^2的时间复杂度跑一遍肯定会TLE，这时候考虑对前缀和的剪枝操作。 Solve A：map 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;map&lt;int,int&gt;k;int max(int x,int y)&#123; if(x&gt;=y)&#123; return x; &#125;else&#123; return y; &#125;&#125;int min(int x,int y)&#123; if(x&gt;=y)&#123; return y; &#125;return x;&#125;int main()&#123; int a=0,b=0; int n; int maxn=0; cin&gt;&gt;n; k[0]=0; char s; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;s; if(s=='1')&#123; a++; &#125;else&#123; b++; &#125; if(k.find(a-b)==k.end())&#123; k[a-b]=i; &#125;else&#123; maxn=max(maxn,i-k[a-b]); &#125; &#125; cout&lt;&lt;maxn&lt;&lt;" "&lt;&lt;min(a,b)*2; &#125; Solve B：二分 既然只是单纯的找0和1相等的子串情况，二分法可能会更好用。]]></content>
      <tags>
        <tag>“前缀和”</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NowCoder.Number]]></title>
    <url>%2F2019%2F07%2F28%2FNowCoder.Number%2F</url>
    <content type="text"><![CDATA[题目描述 链接：https://ac.nowcoder.com/acm/contest/884/K One day he got a string consisted of numbers. He wants to know how many substrings in the string are multiples of 300 when considered as decimal integers. Note that leading and trailing zeros are allowed (both in original string and substrings you chose) and the same substring appearing in different places can be counted multiple times. 输入描述： A single line consisting a string consisted of characters ‘0’ to ‘9’. 输出描述： The number of substrings that are multiples of 300 when considered as decimal integers. 样例输入： 600 样例输出： 4 说明： ‘600’, ‘0’, ‘0’, ‘00’ are multiples of 300. (Note that ‘0’ are counted twice because it appeared two times) 备注： let the string in the input be s, 1≤∣s∣≤10^5 . 问题分析： 因为n^2复杂度在10^5条件下肯定会T，所以排除朴素的求前缀和。 想到二分去做，但是因为要保证子串的有序性，也不可以。 Solve A： O(n)复杂度 这里想到正序和逆序，人工筛选的办法肯定是从后向前筛选，例如333300会先筛选0、0、00、300、3300，33300，333300，在保证00的条件下3333筛了四遍，推广到前缀和的N^2复杂度是肯定不可行的，所以考虑正序——保存前 i 个数正确顺序的条件下，在求第 i + 1 项时直接引用第 i 项的数。 w[i]为前 i 项的和 mod 3的值，对于长度 &gt;=2 的区间 [l,r] 内 只要 w[ l - 1 ] = w[ r ] 且 w [ r - 1 ] , w [ r ]为 0 即满足 也就是说，当 s [i] = 0 时，ans+1，当 s [ i - 1 ] == s [ i ]时，ans+= （ i 之前有多少能满足的条件数目）其中 cn [x] 数组代表出现了多少次 mod3 = x的情况，即 i 时刻 cn [ 0 ] 为 i 之前有多少 组 满足能被300整除的组合数。 你可能会问，为什么不直接写 ans += cn[0]？ 形如78900 w[i]为22222，也就是说不满足前面一串能形成300的倍数的条件时这一串是不被二次计算的。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define maxx 100005char s[maxx]; int n,w[maxx],cn[3];int main()&#123; scanf("%s",s+1); n=strlen(s+1); for(int i=1;i&lt;=n;++i) w[i]=(w[i-1]+s[i])%3; ll ans=0; for(int i=1;i&lt;=n;++i) &#123; if(s[i]=='0') &#123; ++ans; if(s[i-1]=='0') ans+=cn[w[i]]; &#125; cn[w[i-1]]++; &#125; printf("%lld\n",ans); return 0;&#125; Solve B：前缀和+剪枝 Solve C：动态规划]]></content>
      <tags>
        <tag>“前缀和”</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开博点题]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%BC%80%E5%8D%9A%E7%82%B9%E9%A2%98%2F</url>
    <content type="text"><![CDATA[时间是一切财富中最宝贵的财富。 —— 德奥弗拉斯多 这只是一篇单纯的记录开博的文章，如果你点进来，可能会因为里面并没有写什么而感到失望 开博时间是2019.7.26，第一篇博文的发表是在2019.7.27，历史上的今天例如在公元1214年的今天发生了布汶战役，1789年的今天美国成立了国务院，1837年的今天意大利诗人卡尔杜齐出生，1890年的今天梵高开枪自杀等等。 但是今天，我的博客创立了。 虽然对整个世界来说这不是很大的事情，但是我希望几万年之后外星人发现了这一篇博文并且特意将这件事记录在小本本上供后世参考和学习。 言归正传，我还是要拿这一博客当正经的Code与经验交流来用，如有不当之处欢迎大家指正。]]></content>
      <tags>
        <tag>闲谈</tag>
      </tags>
  </entry>
</search>
