<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[20200115 VJ训练赛]]></title>
    <url>%2F2020%2F01%2F16%2F20200115%20VJ%E8%AE%AD%E7%BB%83%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[愉快的Virtual Judge假期训练赛第一场题解报告 重新复盘一下QAQ A. Mezo Playing Zoma 题目描述 给你一串字符串只包含L和R，从0位置开始可以向左向右走也可以不走，问你最多能到达多少个位置。 题目解读 如果给字符串是“L L L”，那么可以选择每一步走或者不走就是-3 -2 -1 0 共4种 如果给字符串是“R R R”，同理 0 1 2 3 共4种 如果给字符串是“R L R”，有-1 0 1 2 共4种 …所以这道题也就是判断LR的数量单独加和最后+1 B. Just Eat It! 题目描述 给你一个数组，数组和为A，一串连续最大字串和为B，问A&gt;=B即输出YES，否则输出NO 题目解读 问题就是求解 数组内连续子段最大和 是多少 首先看看情况都会有哪几种： 第一种：1 2 3 4 5，连续子段最大和为2+3+4+5 第二种：1 2 3 4 -1，连续子段最大和为1+2+3+4 第三种：1 2 3 -1 5，连续子段最大和为2+3+(-1)+5 第四种：1 1 -2 3 4，连续最大子段和为3+4 可以看出，如果要寻找[1,n-1]和[2,n]范围内的最大子段和，需要判断x位置之前的和是否小于0，如果小于0那么就要从x+1位置重新开始，两个范围都跑一遍就好了。 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;long long max(long long a,long long b)&#123; if(a&lt;b)return b; return a;&#125;int main()&#123; int t,n,a[100005]; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; long long k=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); k+=a[i]; &#125; long long x=0,maxx=-1; for(int i=1;i&lt;=n-1;i++)&#123; x+=a[i]; if(x&lt;0) x=0; maxx=max(maxx,x); &#125; x=0; for(int i=2;i&lt;=n;i++)&#123; x+=a[i]; if(x&lt;0) x=0; maxx=max(maxx,x); &#125; if(maxx&lt;k) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; C.Fadi and LCM 题目描述：求一组数的最小公倍数是X，且这一组数的最大值最小。 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;long long gcd(long long a,long long b)&#123; if(b==0)return a; return gcd(b,a%b);&#125;int main()&#123; long long x; cin&gt;&gt;x; for(long long i=sqrt(x);i&gt;=1;i--)&#123; if(x/i*i==x&amp;&amp;gcd(i,x/i)==1)&#123; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;x/i&lt;&lt;endl; break; &#125; &#125; return 0;&#125; Dr. Evil Underscores 异或问题一般都是字典树 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; a;int x;int slove(vector&lt;int&gt; a,int k)&#123; if(a.size()==0||k&lt;0) return 0; //当没有位数了 vector&lt;int&gt; p1,p2; for(int i=0;i&lt;a.size();i++) &#123; if((a[i]&gt;&gt;k)&amp;1) p1.push_back(a[i]); //每个数的每位。是1的存在p1,是0的存在p2 else p2.push_back(a[i]); &#125; if(p1.size()==0) return slove(p2,k-1); if(p2.size()==0) return slove(p1,k-1); return (1&lt;&lt;k)+min(slove(p1,k-1),slove(p2,k-1)); //当前的贡献值+左右子树的最小贡献值。&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;x); a.push_back(x); &#125; cout&lt;&lt;slove(a,30)&lt;&lt;endl;&#125; E. Deadline 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int f(int x,int y)&#123; if((x/y)*y&lt;x)&#123; return x/y+1; &#125;else&#123; return x/y; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; int n,d; cin&gt;&gt;n&gt;&gt;d; bool k=false; for(int i=0;i*i&lt;=d;i++)&#123; if((i+f(d,i+1))&lt;=n)&#123; k=true; &#125; &#125; if(k)cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125; return 0;&#125; F. Yet Another Meme Problem 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; long long a,b; cin&gt;&gt;a&gt;&gt;b; long long x=9,num=0; while(x&lt;=b)&#123; x=x*10+9; num++; &#125; long long ans=num*a; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; G. HQ9+ 就注意“+”是无用信息就可以了 H. Rolling The Polygon 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;struct node&#123;//point int x; int y; double z; double l;&#125;a[55];double find(node p,node q)&#123; return sqrt((p.x-q.x)*(p.x-q.x)+(p.y-q.y)*(p.y-q.y));&#125;int main()&#123; int t; cin&gt;&gt;t; int k=t; node q; while(t--)&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i].x&gt;&gt;a[i].y; &#125; cin&gt;&gt;q.x&gt;&gt;q.y; double aa,bb,cc; for(int i=1;i&lt;=n;i++)&#123; a[i].l=find(a[i],q); if(i==1)&#123; bb=find(a[1],a[2]); aa=find(a[2],a[n]); cc=find(a[n],a[1]); a[1].z=acos((bb*bb+cc*cc-aa*aa)/(2*bb*cc)); &#125;else if(i==n)&#123; bb=find(a[n],a[1]); aa=find(a[1],a[n-1]); cc=find(a[n],a[n-1]); a[n].z=acos((bb*bb+cc*cc-aa*aa)/(2*bb*cc)); &#125;else&#123; bb=find(a[i],a[i+1]); aa=find(a[i+1],a[i-1]); cc=find(a[i],a[i-1]); a[i].z=acos((bb*bb+cc*cc-aa*aa)/(2*bb*cc)); &#125; a[i].z=3.1415926535-a[i].z; &#125; double ans=0.0; for(int i=1;i&lt;=n;i++)&#123; ans+=a[i].z*a[i].l; &#125; printf("Case #%d: %.3f\n",k-t,ans); &#125;&#125;]]></content>
      <tags>
        <tag>“训练赛”</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA Farey Sums]]></title>
    <url>%2F2019%2F08%2F14%2FUVA%20Farey%20Sums%2F</url>
    <content type="text"><![CDATA[题目描述 Given a positive integer, N, the sequence of all fractions a/b with (0 &lt; a ≤ b), (1 &lt; b ≤ N) and a and b relatively prime, listed in increasing order, is called the Farey Sequence of order N.For example, the Farey Sequence of order 6 is: *0/1, 1/6, 1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5, 5/6, 1/1 * If the denominators of the Farey Sequence of order N are: b[1], b[2], . . . , b[K] then the Farey Sum of order N is the sum of b[i]/b[i + 1] from i = 1 to K—1.For example, the Farey Sum of order 6 is: *1/6 + 6/5 + 5/4 + 4/3 + 3/5 + 5/2 + 2/5 + 5/3 + 3/4 + 4/5 + 5/6 + 6/1 = 35/2 * Write a program to compute the Farey Sum of order N (input). 输入 The first line of input contains a single integer P, (1 ≤ P ≤ 10000), which is the number of data sets that follow. Each data set should be processed identically and independently.Each data set consists of a single line of input. It contains the data set number, K, followed by the order N, (2 ≤ N ≤ 10000), of the Farey Sum that is to be computed. 输出 For each data set there is a single line of output. The single output line consists of the data set number,K, followed by a single space followed by the Farey Sum as a decimal fraction in lowest terms. If the denominator is 1, print only the numerator. 样例输入 41 62 153 574 9999 样例输出 1 35/22 215/23 2999/24 91180457/2 这一道题用模拟会T掉 正解是运用欧拉函数。 欧拉函数是用来计算N前有多少与N互质的数的方法。 想学习欧拉函数的可以看这里：https://www.e-learn.cn/content/qita/2190529 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=10003;int jj[inf];void euler()&#123; for (int i=1;i&lt;=inf;i++) jj[i]=i; for(int i=2;i&lt;inf;i++)&#123; if(jj[i]==i) for(int j=i;j&lt;inf;j+=i)&#123; jj[j]=jj[j]/i*(i-1); &#125; jj[i]+=jj[i-1];// &#125;&#125;int main()&#123; int n,k,x,a[10010]; cin&gt;&gt;n; euler(); for(int i=1;i&lt;=15;i++)&#123; cout&lt;&lt;jj[i]&lt;&lt;" "; &#125; while(n--) &#123; scanf("%d%d",&amp;k,&amp;x); cout&lt;&lt;k&lt;&lt;" "&lt;&lt;jj[x]*3-1&lt;&lt;"/2"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA Height Ordering]]></title>
    <url>%2F2019%2F08%2F14%2FUVA%20Height%20Ordering%2F</url>
    <content type="text"><![CDATA[题目描述 Mrs. Chambers always has her class line up in height order (shortest at the front of the line). Every September a new class of exactly 20 3rd graders arrive, all of different height. For the first few days it takes a long time to get the kids in height order, since no one knows where they should be in the line.Needless to say, there is quite a bit of jockeying around. This year Mrs. Chambers decided to try a new method to minimize this ordering chaos. One student would be selected to be the first person in line. Then, another student is selected and would find the rst person in the line that is taller than him,and stand in front of that person, thereby causing all the students behind him to step back to make room. If there is no student that is taller, then he would stand at the end of the line. This process continues, one student at-a-time, until all the students are in line, at which point the students will be lined up in height order.For this problem, you will write a program that calculates the total number of steps taken back during the ordering process for a given class of students. 输入 The first line of input contains a single integer P, (1 ≤ P ≤ 1000), which is the number of data sets that follow. Each data set should be processed identically and independently.Each data set consists of a single line of input. It contains the data set number, K, followed by 20 non-negative unique integers separated by a single space. The 20 integers represent the height (in millimeters) of each student in the class. 输出 For each data set there is one line of output. The single output line consists of the data set number,K, followed by a single space followed by total number of steps taken back. 样例输入 41 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 9192 919 918 917 916 915 914 913 912 911 910 909 908 907 906 905 904 903 902 901 9003 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 9004 918 917 916 915 914 913 912 911 910 909 908 907 906 905 904 903 902 901 900 919 样例输出 1 02 1903 194 17 弧了好久没更新博客..实际上是前几天去考科目二了（险过，丢人） 这道题第一眼就感觉用upper_bound，就算数据水但是还有打的必要的 upper_bound的作用就是寻找比较一个vector大数的位置并且返回，这里找一下然后算一下位置求和就好了 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int n;vector&lt;int&gt; shu;int main()&#123; scanf("%d",&amp;n); long long s=0; int kk[25]; for(int i=1;i&lt;=n;i++)&#123; int num; s=0; shu.clear(); scanf("%d",&amp;num);; for(int j=1;j&lt;=20;j++)&#123; scanf("%d",&amp;kk[j]); s+=shu.end()-upper_bound(shu.begin(),shu.end(),kk[j]); shu.insert(upper_bound(shu.begin(),shu.end(),kk[j]),kk[j]); &#125; printf("%d %d\n",i,s); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder.JOIOJI]]></title>
    <url>%2F2019%2F07%2F29%2FAtcoder.JOIOJI%2F</url>
    <content type="text"><![CDATA[题目描述 JOIOJI桑是JOI君的叔叔。“JOIOJI”这个名字是由“J、O、I”三个字母各两个构成的。 最近，JOIOJI桑有了一个孩子。JOIOJI桑想让自己孩子的名字和自己一样由“J、O、I”三个字母构成，并且想让“J、O、I”三个字母的出现次数恰好相同 。 JOIOJI桑家有一份祖传的卷轴，上面写着一首长诗，长度为N，由“J、O、I”三个字母组成。JOIOJIさん想用诗中最长的满足要求的连续子串作为孩子的名字。 现在JOIOJI桑将这首长诗交给了你，请你求出诗中最长的、包含同样数目的“J、O、I”三个字母的连续子串。 输入 第一行一个正整数N，代表这首长诗的长度 接下来一行一个长度为N的字符串S，表示这首长诗，保证每个字符都是“J、O、I”三个字母中的一个 N&lt;=200000 输出 输出一行一个正整数，代表最长的包含等数量“J、O、I”三个字母的最长连续子串的长度。如果不存在这样的子串，输出0 样例输入 10 JOIIJOJOOI 样例输出 6 同样，2*10^5数据范围 N * N肯定也不可行，考虑别的办法。 思路参考引自：https://fighting-naruto.blog.luogu.org/solution-at1224 如果用1，2，3分别代表 J,O,I ，用 si[j] 表示 前 j 个位置有多少个 i ，那么区间[i,j]满足条件有： s1[j] - s1[i-1] = s2[j] - s2[i-1] = s3[j] - s3[i-1] 移项化简 设s2[i] - s1[i] = x[i] , s3[i] - s1[i] = y[i]，则只要满足x[j]=x[i-1]并且y[j] = y[i-1]就说明区间[i,j]满足条件 最后只需要找x,y相同的最大的区间[i,j]即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int N = 200005;typedef long long ll;using namespace std;ll ans=0;struct node&#123; int x,y,id;&#125;a[N];char ch;bool cmp(node a,node b)&#123; return a.x&lt;b.x || (a.x==b.x&amp;&amp;a.y&lt;b.y)|| (a.x==b.x&amp;&amp;a.y==b.y&amp;&amp;a.id&lt;b.id);&#125;ll maxx(ll xx,ll yy)&#123; if(xx&gt;yy)&#123; return xx; &#125;return yy;&#125;int main()&#123; int n; cin&gt;&gt;n;//x[i]=s2[i]-s1[i] y[i]=s3[i]-s1[i] for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;ch; a[i].id=i; if(ch=='J')&#123; a[i].x=a[i-1].x-1; a[i].y=a[i-1].y-1; &#125;if(ch=='O')&#123; a[i].x=a[i-1].x+1; a[i].y=a[i-1].y; &#125;if(ch=='I')&#123; a[i].x=a[i-1].x; a[i].y=a[i-1].y+1; &#125; &#125; sort(a,a+n+1,cmp); int t=a[0].id; for(ll i=1;i&lt;=n;i++)&#123; if(a[i].x==a[i-1].x &amp;&amp; a[i].y==a[i-1].y) ans=maxx(ans,a[i].id-t); else t=a[i].id; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NowCoder Crazy Binary String]]></title>
    <url>%2F2019%2F07%2F29%2FNowCoder.CrazyBinaryString%2F</url>
    <content type="text"><![CDATA[题目描述 链接：https://ac.nowcoder.com/acm/contest/883/B ZYB loves binary strings (strings that only contains 0 and1’). And he loves equal binary strings more, where the number of 0and the number of 1 in the string are equal. ZYB wants to choose a substring from an original string T so that it is an equal binary stringwith the longest length possible. He also wants to choose a subsequence of T which meets the same requirements. A string v is a substring of a string w if v is empty, or there are two integers l and r (1≤l≤r≤∣w∣) such that v=wl*wl+1 ⋯wr A string v is a subsequence of a string w if it can be derived from w by deleting any number (including zero) of characters without changing the order of the remaining characters. For simplicity, you only need to output the maximum possible length. Note that the empty string is both a substring and a subsequence of any string. 输入描述 The first line of the input contains a single integer N (1≤N≤100000)，the length of the original string T. The second line contains a binary string with exactly N characters, the original string T 输出描述 Print two integers A and B, denoting the answer for substring and subsequence respectively. 示例输入 8 0100101001 示例输出 4 6 分析这道题目的时候，10^5用N^2的时间复杂度跑一遍肯定会TLE，这时候考虑对前缀和的剪枝操作。 Solve A：map 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;map&lt;int,int&gt;k;int max(int x,int y)&#123; if(x&gt;=y)&#123; return x; &#125;else&#123; return y; &#125;&#125;int min(int x,int y)&#123; if(x&gt;=y)&#123; return y; &#125;return x;&#125;int main()&#123; int a=0,b=0; int n; int maxn=0; cin&gt;&gt;n; k[0]=0; char s; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;s; if(s=='1')&#123; a++; &#125;else&#123; b++; &#125; if(k.find(a-b)==k.end())&#123; k[a-b]=i; &#125;else&#123; maxn=max(maxn,i-k[a-b]); &#125; &#125; cout&lt;&lt;maxn&lt;&lt;" "&lt;&lt;min(a,b)*2; &#125; Solve B：前缀和 贯彻数学思想的前缀和…这种简单的做法基本换汤不换药，记得归纳总结。 设s1[i]为前i项0的个数，s2[i]为前i项1的个数，所以[i,j]范围内有0 s1[j]-s1[i-1]个，1 s2[j]-s2[i-1]个。 列出方程式 s1[j]-s1[i-1] = s2[j]-s2[i-1] 移项得 s1[j]-s2[j] = s1[i-1] - s2[i-1] 设x[i] = s1[i] - s2[i] 得到当x[j] = x[i-1] 时 满足情况。 写一个结构体，重新排序一下，然后取 x[j]=x[i-1] 的情况即可（此方法适用于各种前缀和N^2 TLE 求子串含有相同字符的时候） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int N = 200005;typedef long long ll;using namespace std;ll ans=0;struct node&#123; int x,id;&#125;a[N];char ch;bool cmp(node a,node b)&#123; return a.x&lt;b.x || (a.x==b.x&amp;&amp;a.id&lt;b.id);&#125;ll maxx(ll xx,ll yy)&#123; if(xx&gt;yy)&#123; return xx; &#125;return yy;&#125;ll minn(ll xx,ll yy)&#123; if(xx&gt;yy)&#123; return yy; &#125;return xx;&#125;int main()&#123; int n; cin&gt;&gt;n; ll zero=0,one=0; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;ch; a[i].id=i; if(ch=='0')&#123; a[i].x=a[i-1].x+1; zero++; &#125;else&#123; a[i].x=a[i-1].x-1; one++; &#125; &#125; sort(a,a+n+1,cmp); int t=a[0].id; for(ll i=1;i&lt;=n;i++)&#123; if(a[i].x==a[i-1].x) ans=maxx(ans,a[i].id-t); else t=a[i].id; &#125; cout&lt;&lt;ans&lt;&lt;" "&lt;&lt;2*minn(zero,one)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NowCoder.Number]]></title>
    <url>%2F2019%2F07%2F28%2FNowCoder.Number%2F</url>
    <content type="text"><![CDATA[题目描述 链接：https://ac.nowcoder.com/acm/contest/884/K One day he got a string consisted of numbers. He wants to know how many substrings in the string are multiples of 300 when considered as decimal integers. Note that leading and trailing zeros are allowed (both in original string and substrings you chose) and the same substring appearing in different places can be counted multiple times. 输入描述： A single line consisting a string consisted of characters ‘0’ to ‘9’. 输出描述： The number of substrings that are multiples of 300 when considered as decimal integers. 样例输入： 600 样例输出： 4 说明： ‘600’, ‘0’, ‘0’, ‘00’ are multiples of 300. (Note that ‘0’ are counted twice because it appeared two times) 备注： let the string in the input be s, 1≤∣s∣≤10^5 . 问题分析： 因为n^2复杂度在10^5条件下肯定会T，所以排除朴素的求前缀和。 想到二分去做，但是因为要保证子串的有序性，也不可以。 Solve A： O(n)复杂度 这里想到正序和逆序，人工筛选的办法肯定是从后向前筛选，例如333300会先筛选0、0、00、300、3300，33300，333300，在保证00的条件下3333筛了四遍，推广到前缀和的N^2复杂度是肯定不可行的，所以考虑正序——保存前 i 个数正确顺序的条件下，在求第 i + 1 项时直接引用第 i 项的数。 w[i]为前 i 项的和 mod 3的值，对于长度 &gt;=2 的区间 [l,r] 内 只要 w[ l - 1 ] = w[ r ] 且 w [ r - 1 ] , w [ r ]为 0 即满足 也就是说，当 s [i] = 0 时，ans+1，当 s [ i - 1 ] == s [ i ]时，ans+= （ i 之前有多少能满足的条件数目）其中 cn [x] 数组代表出现了多少次 mod3 = x的情况，即 i 时刻 cn [ 0 ] 为 i 之前有多少 组 满足能被300整除的组合数。 你可能会问，为什么不直接写 ans += cn[0]？ 形如78900 w[i]为22222，也就是说不满足前面一串能形成300的倍数的条件时这一串是不被二次计算的。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define maxx 100005char s[maxx]; int n,w[maxx],cn[3];int main()&#123; scanf("%s",s+1); n=strlen(s+1); for(int i=1;i&lt;=n;++i) w[i]=(w[i-1]+s[i])%3; ll ans=0; for(int i=1;i&lt;=n;++i) &#123; if(s[i]=='0') &#123; ++ans; if(s[i-1]=='0') ans+=cn[w[i]]; &#125; cn[w[i-1]]++; &#125; printf("%lld\n",ans); return 0;&#125; Solve B：前缀和+剪枝 Solve C：动态规划]]></content>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开博点题]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%BC%80%E5%8D%9A%E7%82%B9%E9%A2%98%2F</url>
    <content type="text"><![CDATA[时间是一切财富中最宝贵的财富。 —— 德奥弗拉斯多 这只是一篇单纯的记录开博的文章，如果你点进来，可能会因为里面并没有写什么而感到失望 开博时间是2019.7.26，第一篇博文的发表是在2019.7.27，历史上的今天例如在公元1214年的今天发生了布汶战役，1789年的今天美国成立了国务院，1837年的今天意大利诗人卡尔杜齐出生，1890年的今天梵高开枪自杀等等。 但是今天，我的博客创立了。 虽然对整个世界来说这不是很大的事情，但是我希望几万年之后外星人发现了这一篇博文并且特意将这件事记录在小本本上供后世参考和学习。 言归正传，我还是要拿这一博客当正经的Code与经验交流来用，如有不当之处欢迎大家指正。]]></content>
      <tags>
        <tag>闲谈</tag>
      </tags>
  </entry>
</search>
